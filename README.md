The C++ chess game implemented in the provided code enables two players to engage in a console-based chess match. It involves a significant number of features and functions that ensure the game adheres to the standard rules of chess. The game is structured to be interactive, allowing users to input their moves either via the keyboard or mouse, while also providing various checks for move validity, piece-specific movement rules, and handling complex game mechanics like castling, en passant, and pawn promotion.


At its core, the chessboard is represented as a two-dimensional array. This array is used to place and display pieces during the game, with each square of the board identified by a row and column. The board is set up with the standard chess piece arrangement at the start, where the pieces are assigned designated characters like 'R' for a white rook, 'N' for a white knight, 'K' for a white king, and so on. Black pieces are assigned lowercase letters like 'r' for a black rook and 'n' for a black knight. The game also utilizes an additional MegaBoard array, which serves to manage visual effects for each square on the board, including special effects that may be displayed depending on the board state or type of piece occupying the square. This allows for an enhanced and dynamic visualization of the game state during play.


The game runs in a loop, which continues until a checkmate or draw condition is met. A boolean variable is used to determine whose turn it is, alternating between Player 1 (white pieces) and Player 2 (black pieces). This turn-switching mechanism is implemented within the turnChange() function, which is called after each move to alternate control of the game. The game includes built-in checks for various conditions, including whether a player is in check or if checkmate has been achieved.


To facilitate gameplay, the program allows players to input their moves using either the keyboard or mouse. The keyboard input mechanism is handled through the sourceInput() and DestinationInput() functions, which capture the player's desired move by asking for a starting position (source) and an ending position (destination) in standard chess notation (e.g., "e2" to "e4"). If the player prefers using the mouse, the game supports mouse input through the inputbyclick() function, which allows the player to click on the source and destination squares directly on the board, making the game more accessible and intuitive for different user preferences.


Once the source and destination of a move are determined, the game proceeds to validate the move. The validSource() function checks whether the selected square contains a piece belonging to the current player, ensuring that players cannot accidentally select their opponent's pieces. Following this, the game verifies that the move is legal according to the rules governing each type of piece. The pawn() function handles pawn movement, ensuring that pawns can move either one square forward or two squares on their first move, as per chess rules. Pawns are also checked for the ability to capture diagonally and can potentially promote to a queen, rook, knight, or bishop upon reaching the opposite side of the board. Similarly, the other piece types are validated using their respective movement functions.


The Rook(), bishop(), knight(), and king() functions each ensure that their respective pieces move in accordance with the rules of chess. The rook moves horizontally or vertically across the board, provided there are no other pieces in its path. The bishop moves diagonally and is similarly restricted by the presence of other pieces. The knight follows an "L" shaped pattern and is the only piece that can jump over others. The king, as the most critical piece in chess, can move one square in any direction. Each of these functions checks for these movement patterns and ensures that the game rules are adhered to. In the case of castling, the king() and rook() functions are used to determine whether castling is possible, ensuring that the squares between the king and rook are unoccupied, the king has not moved, and no pieces threaten the involved squares.

In addition to piece movement, the game must check whether the player’s king is in check or checkmate. The IsCheck() function scans the board for any opponent pieces that threaten the player's king, while the isCheckmate() function checks if the game has reached a checkmate situation. If the player’s king is in check and no legal moves are available to escape the check, the game ends and announces the winner. Conversely, a stalemate or draw can also be declared if no legal moves exist and the player's king is not in check.

To support more strategic gameplay, the game includes the ability to undo moves. The undo() function allows players to revert to the previous board state, which is saved in a file named board.txt. After each move, the current state of the board is written to this file, enabling players to undo their last move and return to the previous game state. This is especially helpful in providing an option to correct mistakes and experiment with different moves.

Furthermore, the game provides the option to save progress at any point. The board.txt file serves not only as a record for undoing moves but also as a means to save the current game state. This allows players to pause and resume the game later without losing their progress. By saving the board state in a file after each move, players can resume the game at any time, making the game more flexible and convenient for players who may need to take breaks.


Memory management is also handled efficiently in the code. The game ensures that dynamically allocated memory is properly freed after each round of play to avoid memory leaks. After every move, the dynamically allocated memory for the board and MegaBoard is deleted, ensuring optimal use of system resources. This careful attention to memory management ensures that the game runs smoothly without consuming unnecessary system resources.

As the game progresses, players may also restart the game at any time by calling the restart() function. This function resets the board to its initial setup and reinitializes all variables, effectively starting a new game from scratch. This provides an easy way for players to begin a new game without needing to close and reopen the program.


The game interface is designed to be simple and easy to use, running entirely in the console. This means that it can be run on various platforms without requiring complex graphical resources. The use of text-based chess pieces and basic visual effects ensures that the game is both lightweight and user-friendly, while still retaining the full depth and complexity of a chess game.

Overall, this C++ chess game offers a comprehensive chess-playing experience. It supports all the standard rules and mechanics of chess, including special moves such as castling, en passant, and pawn promotion. The game’s flexibility in terms of input methods (keyboard and mouse) and its ability to undo moves and save progress make it user-friendly and accessible. Additionally, the game's careful management of resources, including memory handling and file-based saving, ensures that it operates efficiently. Whether you’re a beginner looking to learn the game or an experienced player seeking a challenging match, this chess program provides an excellent platform for playing chess.



